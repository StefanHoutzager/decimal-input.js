<!DOCTYPE html>

<html style='height: 100%;'>
  <head>
    <meta charset="UTF-8">
    <script type='text/javascript'>
      const addThousandsSeparators = (e, intPart) => 
        [...intPart]
        .reverse()
        .reduce((returnValue, digit, index) => returnValue += (index % 3 == 0 ? (thousandsSeparator(e.target) + digit) : digit))
        .split('')
        .reverse()
        .join(''); 

      const backspaceKeyDownIntegerPart = e => {
        if (jumpOverSeparator(e)) {
          return -1;
        } 		
        if (isWholeValueSelected(e)) {
          printDefaultValue(e.target);
          return 0;
        }		
        if (isNegative(e.target.value) && e.target.selectionStart === 1 && nothingIsSelected(e)) {
          e.target.value = substring(e.target.value, 1);
          return 0;
        }
        if ( // there is one integer digit, cursor right of it or the integerpart is selected  
            ((e.target.selectionStart === 1 || (e.target.selectionStart === 2 && isNegative(e.target.value))) && nothingIsSelected(e) && integerPart(e).length === 1)
             || (cursorLeftOfFirstDigit(e) && e.target.selectionEnd === endOfIntegerPartLocation(e)) 
           ) { 
          e.target.value = replaceWithIntPart(e, '0');
          return -1;  
        }
        else {
          const nothingSelected = nothingIsSelected(e);
          let elementValue = '';
          if (cursorLeftOfFirstDigit(e) && decSeparatorInSelection(e)) {
            elementValue = replaceWithIntPart(e, '0');
          }
          else {
            elementValue = replaceWithIntPart(e, '');
          }	
          elementValue   = decSeparatorInSelection(e) && numSelectedDecimals(e) > 0 ? replaceAtDecPart(elementValue, e) : elementValue;
          elementValue   = removeLeadingZeros(elementValue, e); 
          e.target.value = elementValue;	
          return updatethousandsSeparators(e) + (nothingSelected ? 0 : 1);		
        }				
      }; 
	  
      const clipboardContainsDisallowedCharacters = e => e.clipboardData.getData('text/plain').split('').filter(x => !isAllowedCharacter(e, x)).length > 0;
	  
      const correctCharacterInputViaNumpadAndDeadKeys = element => {
        if (element.altKeyDown || [...element.value].filter(x => ['^','`','~'].includes(x)).length > 0) {
          const selectionStart = element.selectionStart - 1;
          element.value          = element.oldValue;
          element.selectionStart = selectionStart;
          element.selectionEnd   = selectionStart;
        }	  
      };	  	  
	   
      const cursorIsInDecimalPart   = e => 
         decSeparatorLoc(e.target) > -1 
         && cursorPositionRight(e) <= numDecimals(e)
         && cursorPositionRight(e) >= 0;	   
	   
      const cursorLeftOfFirstDigit  = e => isNegative(e.target.value) ? [0, 1].includes(e.target.selectionStart) : e.target.selectionStart === 0; 
	    	  
      const cursorPositionRight     = e => e.target.value.length - e.target.selectionStart;
	 
      const decimalSeparatorDefault = () => 1.1.toLocaleString().substring(1,2);	  
			
      const decimalSeparator        = element => element.hasAttribute('decimalSeparator') ? element.getAttribute('decimalSeparator') : decimalSeparatorDefault();
	  
      const decSeparatorInSelection = e => 
        (e.target.selectionEnd - e.target.selectionStart > 1) 
        && decSeparatorLoc(e.target) >= e.target.selectionStart 
        && decSeparatorLoc(e.target) < e.target.selectionEnd; 									
			
      const decSeparatorLoc         = element => element.value.lastIndexOf(decimalSeparator(element));
	  	  
      const deleteKeyDownIntegerPart = e => {
        if (jumpOverSeparator(e)) {		
          return 1;
        } 	
        if (isWholeValueSelected(e)) {
          printDefaultValue(e.target);
          return 0;
        }
        if (cursorLeftOfFirstDigit(e)) { 
          if (integerPart(e).length === 1 
              || (e.target.selectionEnd >= decSeparatorLoc(e.target) && isInputWithDecimals(e))
             ) { 
            let elementValue = replaceWithIntPart(e, '0');	
            if ((e.target.selectionEnd > decSeparatorLoc(e.target) + 1) && isInputWithDecimals(e)) {
              elementValue = replaceAtDecPart(elementValue, e);	
            }		
            e.target.value = elementValue;
            return 1;
          }  
          else if(!isInputWithDecimals(e) && isWholeValueSelected(e)) {
            e.target.value = '0';
            return 0;
          }
          else {
            let elementValue = replaceWithIntPart(e, '');
            elementValue   = removeLeadingZeros(elementValue, e); 
            e.target.value = elementValue;
          }
        }	
        else {
              let elementValue = replaceWithIntPart(e, '');
              elementValue   = removeLeadingZeros(elementValue, e);
              elementValue   = ((e.target.selectionEnd > decSeparatorLoc(e.target) + 1) && numDecimalsInFormat(e.target) > 0) ? replaceAtDecPart(elementValue, e) : elementValue;
              e.target.value = elementValue;		
        }					
        return updatethousandsSeparators(e);	  
      };
	  
      const endOfIntegerPartLocation = e  => numDecimals(e) > 0 ? decSeparatorLoc(e.target) : e.target.value.length;	  
	    
      const handleOnKeydown = e  => {
        e.target.altKeyDown = e.altKey; 
        e.target.oldValue   = e.target.value;

        if ((e.key.startsWith('F') && e.key.length > 1)) {return true;}
		
        const selectionStart = e.target.selectionStart;
        let   resetCursor    = 0;

        if (!e.shiftKey) {  
          // The value of the input is divided in an integer- and a decimal part to ease the handling of their different properties.
          // For example: in the integerpart placement of thousandseparators has to be handled, if a number is typed or delete or backspace, 
          // after the decimal separator, the number affected is replaced in the decimalpart while this happens in the integerpart only 
          // when the integervalue is zero. The value of resetCursor is calculated and returned by the functions and is used to replace the cursor 
          resetCursor = cursorIsInDecimalPart(e) ? keyDownDecimalPart(e) : keyDownIntegerPart(e); 
        }
			  		  
        if ((!isSpecialKey(e) || isADigit(e.key) || isDeleteKey(e) || e.key === 'Backspace' || isDecimalSeparatorKey(e) || e.key === '-')  
          && !e.ctrlKey) {  
          e.preventDefault();
          e.stopPropagation();
          e.target.selectionStart = (isDecimalSeparatorKey(e) && numDecimalsInFormat(e.target)) > 0 ? (decSeparatorLoc(e.target) + 1) : (selectionStart + resetCursor < 0 ? 0 : selectionStart + resetCursor);
          e.target.selectionEnd   = e.target.selectionStart;
          return false;
        } 		
      };
	  
      const handleOnPaste = e  => {
        if (e.clipboardData.getData('text/plain') != '') {
          const validationMessage = validatePasteValue(e);
          if (validationMessage === '') {  
            const clipboardData = removeLeadingZeros(removeThousandsSeparators(e.target, e.clipboardData.getData('text/plain')), e);
            if (numDecimalsInFormat(e.target) > 0 ) { 
              const clipboardDataContainsDecimalSeparator = clipboardData.lastIndexOf(decimalSeparator(e.target)) > 0;
              const numDecimalsToAdd = numDecimalsInFormat(e.target) - (clipboardDataContainsDecimalSeparator ? clipboardData.split(decimalSeparator(e.target))[1].length : 0);
              if (clipboardDataContainsDecimalSeparator) {
                e.target.value = clipboardData + (numDecimalsToAdd > 0 ? '0'.repeat(numDecimalsToAdd) : '');
              } 	
              else {
                e.target.value = clipboardData + decimalSeparator(e.target) + '0'.repeat(numDecimalsToAdd);
              }			
            }
            else {
              e.target.value = clipboardData; 
            }	
            const dummy = updatethousandsSeparators(e);
          }
          else {
            showMessage(e, validationMessage); 
          }
        }
        e.preventDefault();
        e.stopPropagation();
        return false;		
      };
	  
      const insertNumberKey = e =>
        (isNegative(e.target.value) ? ('-' + (e.target.value.slice(e.target.value.startsWith('-0') ? 2 : 1, e.target.selectionStart))) :
        (e.target.value.slice(e.target.value.startsWith('0') ? 1 : 0, e.target.selectionStart))) 
         + e.key 
         + e.target.value.slice(decSeparatorInSelection(e) ? decSeparatorLoc(e.target) : e.target.selectionEnd);
											   
      const insertStyleSheetRule = ruleText => {
        const sheets = document.styleSheets;

        if(sheets.length == 0) {
          let style = document.createElement('style');
          style.appendChild(document.createTextNode(''));
          document.head.appendChild(style);
        }
		 
        let sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
      };
		 
      const integerPart = e   => 
        decSeparatorLoc(e.target) > 0 ? e.target.value.slice(isNegative(e.target.value) ? 1 : 0, decSeparatorLoc(e.target)) : 
        e.target.value.substring(isNegative(e.target.value) ? 1 : 0);
																			  
      const isAllowedCharacter = (e, val) => 
        numbersArray().includes(val) 
        || (val === decimalSeparator(e.target) && e.target.hasAttribute('numDecimals')) 
        ||  val === thousandsSeparator(e.target)
        || (val === '-' && e.target.hasAttribute('allowNegativeSign')) ;																		  
      
      const isDecimalSeparatorKey    = e   => ((e.key === 'Delete' || e.key === 'Del' /* MS Edge */) && e.location === 3) || e.key === decimalSeparator(e.target); 
	  
      const isInputWithDecimals      = e   => numDecimalsInFormat(e.target) > 0
	  
      const isDeleteKey              = e   => ((e.key === 'Delete' || e.key === 'Del' /* MS Edge */) && e.location !== 3);
	  
      const isNegative               = val => val.startsWith('-');
	  
      const isADigit                 = val => (numbersArray().includes(val));	 

      const isSpecialKey             = e   => ['Tab', 'Enter', 'ArrowLeft', 'ArrowRight', 'Left' /* MS Edge */, 'Right' /* MS Edge */].includes(e.key);
	  
      const isWholeValueSelected     = e   => e.target.selectionStart === 0 && e.target.selectionEnd === e.target.value.length;
			
      const jumpOverSeparator = e  =>  
        nothingIsSelected(e) 
        && [e.target.value.indexOf(thousandsSeparator(e.target)), decSeparatorLoc(e.target)].includes(e.target.selectionStart - (isDeleteKey(e) ? 0 : 1));		

      const keyDownDecimalPart = e => {
        if (e.key === 'Backspace') {
          const nothingSelected = nothingIsSelected(e);
          if (numSelectedDecimals(e) > 0 || numDecimalsInFormat(e.target) > cursorPositionRight(e)) {
            e.target.value = replaceAtDecPart(e.target.value, e); 
          }		
          return (nothingSelected ? -1 : 0);
        }		  
        if (isDeleteKey(e) && cursorPositionRight(e) !== 0) { 
          e.target.value = replaceAtDecPart(e.target.value, e);
          return 1;
        }	
        if (isADigit(e.key)) { 
          if (cursorPositionRight(e) != 0) {	
    	    e.target.value = replaceAtDecPart(e.target.value, e);
            return 1;
          }		
        }
        return 0;	  
      };		
	  
      const keyDownIntegerPart = e  => {  
        if (isDeleteKey(e)) { 
          return deleteKeyDownIntegerPart(e);
        }  
        if (e.key === 'Backspace') {
          return backspaceKeyDownIntegerPart(e);
        }
        if (isDecimalSeparatorKey(e) && decSeparatorLoc(e.target) > -1) {
          return 1;
        }
        if (isADigit(e.key) && (numDigitsAllowed(e) || !nothingIsSelected(e))) {
          return numberKeyDownIntegerPart(e);	
        }
        if (e.key === '-' && e.target.hasAttribute('allowNegativeSign') && e.target.selectionStart === 0) {
          if (!isNegative(e.target.value) && nothingIsSelected(e)) {
             e.target.value = '-' + e.target.value;
          }
          else if (!nothingIsSelected(e) && !decSeparatorInSelection(e) && (integerPart(e).length > (e.target.selectionEnd - e.target.selectionStart))) {
            e.target.value = '-' + e.target.value.substring(e.target.selectionEnd);
            const dummy = updatethousandsSeparators(e);
          }		
          return 1;
        }
        return 0;
      };
 
      const maxDigitsInFormat = element => {
        if (element.hasAttribute('maxDigits') )  {
          const digits = parseInt(element.getAttribute('maxDigits'));
          if (!(digits > 0)) {
            setConfigError(element, 'maxDigits attribute ' + element.getAttribute('maxDigits') + ' should be an integer value above zero.');
            return 0; 
          }
          if (digits > 0 && (digits >= numDecimalsInFormat(element))) {return digits;}
          if (digits <= numDecimalsInFormat(element)) {
            setConfigError(element, 'maxDigits attribute should be greater than numDecimals.'); 
            return 0;
          }
        }   
        setConfigError(element, 'maxDigits attribute not set for this element.'); 
        return 0;
      };	
		
      const nothingIsSelected = e  => e.target.selectionStart === e.target.selectionEnd;
	   
      const numberKeyDownIntegerPart = e =>	{	 
        if (cursorLeftOfFirstDigit(e)) {
          if (   e.key === '0'
              && (nothingIsSelected(e) || (integerPart(e).length != 1 && integerPart(e).length > e.target.selectionEnd))
             ) {
            return 0;	
          } 	
          if ((e.target.selectionEnd === 0 || (e.target.selectionEnd === 1 && isNegative(e.target.value)))
              && integerPart(e) === '0') {
            e.target.value = (isNegative(e.target.value) ? '-' : '') + e.key + e.target.value.substring(isNegative(e.target.value) ? 2 : 1);
            return 1;
          }
        }  
        const integerPartBeforeUpdate = integerPart(e);
        e.target.value = insertNumberKey(e);
        if (integerPart(e).length <= 3) { 
          // if the inserted number replaced a zero let the cursor at the same position, otherwise put it one position to the right 
          return integerPartBeforeUpdate.length === integerPart(e).length ? 0 : 1;
        }
        return updatethousandsSeparators(e);
      };	
	  
      const numbersArray           = () => ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
	  
      const numDecimals            = e  => decSeparatorLoc(e.target) > -1 ? e.target.value.split(decimalSeparator(e.target))[1].length : 0;
	  
      const numDecimalsInClipboard = e  => 
        e.clipboardData.getData('text/plain').indexOf(decimalSeparator(e.target)) === -1 ? 0 : 
        e.clipboardData.getData('text/plain').split(decimalSeparator(e.target))[1].length;
	  
      const numDecimalsInFormat = element => {
        if (element.hasAttribute('numDecimals')) {
          const decs = parseInt(element.getAttribute('numDecimals'));
          if (decs > 0) {return decs;}
          setConfigError(element, 'numDecimals attribute ' + element.getAttribute('numDecimals') + ' should be an integer value above zero.'); 
          return 0;
        }   
        return 0;
      };  
																	
      const numDigitsTargetValue        = e => e.target.value.split('').filter(char => !isNaN(char)).length;		
	  
      const numDigitsAllowed            = e => (numDigitsTargetValue(e) + 1 /* + 1 because numDigitsTargetValue is executed on keydown */) <= maxDigitsInFormat(e.target);	
	  
      const numDigitsInClipboard        = e => e.clipboardData.getData('text/plain').split('').filter(char => !isNaN(char)).length;
	  
      const numDigitsInClipboardAllowed = e => numDigitsInClipboard(e) <= maxDigitsInFormat(e.target);	

      const numSelectedDecimals         = e => 
        e.target.value.substring(
          (e.target.selectionStart > decSeparatorLoc(e.target) ? e.target.selectionStart : decSeparatorLoc(e.target) + 1), 
          e.target.selectionEnd
        ).length;		

      const numThousandsSeparators = (element, inputValue) => [...inputValue].reduce((a, c) => c === thousandsSeparator(element) ? ++a : a, 0);
			
      const printDefaultValue = element =>  {
        if (numDecimalsInFormat(element) > 0) {
          element.value = '0' + decimalSeparator(element) + '0'.repeat(numDecimalsInFormat(element));
        }
        else {
          element.value = '0';
        }
         /* value in the autofocus field should be selected */
        if (element.hasAttribute('autofocus')) {
          element.selectionStart = 0;
          element.selectionEnd   = element.value.length;
        }		
      }; 		
 
      const removeLeadingZeros = (elementValue, e) => {
        const negativeValue = isNegative(elementValue);
        let   returnValue   = negativeValue ? elementValue.substring(1) : elementValue;
		
        while (
               (returnValue.startsWith('0') && returnValue.split(decimalSeparator(e.target))[0].length > 1) 
                || returnValue.startsWith(thousandsSeparator(e.target))
              ) {
          returnValue = returnValue.substring(1);
        }
        if (negativeValue) {
          returnValue = '-' + returnValue;
        }
        return returnValue;
      };
	  
      const removeThousandsSeparators = (element, value) => value.split(thousandsSeparator(element)).join('');	  

      const replaceAtDecPart = (elementValue, e) => { 			                                                        
        const insertString = isDeleteKey(e) || e.key === 'Backspace' ? '0'.repeat(numSelectedDecimals(e) || 1) : e.key; 
        let   startString  = '';

        if (isDeleteKey(e)) {
          startString = cursorIsInDecimalPart(e) ? elementValue.substring(0, e.target.selectionStart) : elementValue.substring(0, elementValue.indexOf(decimalSeparator(e.target)) + 1);
        }
        else if (e.key === 'Backspace') {
          startString = cursorIsInDecimalPart(e) ? elementValue.substring(0, e.target.selectionStart - (nothingIsSelected(e) ? 1 : 0)) 
                        : elementValue.substring(0, elementValue.indexOf(decimalSeparator(e.target)) + 1);
        }
        else { 
          startString = elementValue.substring(0, cursorIsInDecimalPart(e) ? e.target.selectionStart : decSeparatorLoc(e.target)); 
        } 
        return startString + insertString + elementValue.substring((startString + insertString).length);  
      };
																	
      const replaceWithIntPart = (e, replace) => {
        let startString = e.target.value.substring(0, e.target.selectionStart),
            endString   = e.target.value.substring(decSeparatorInSelection(e) ? decSeparatorLoc(e.target) : e.target.selectionEnd);
			
        if (nothingIsSelected(e)) {
          // only integer part 
          if (e.key === 'Backspace') {
            startString = e.target.value.substring(0, e.target.selectionStart - 1);
          }
          else if (isDeleteKey(e)) {
            endString = e.target.value.substring(decSeparatorInSelection(e) ? decSeparatorLoc(e.target) : (e.target.selectionEnd + 1))};
          }
          return startString + replace + endString;
      }; 
			
      const setAnimation = (element, animation) => {
        element.style.animation       = animation;
        element.style.WebkitAnimation = element.style.animation;
        element.style.MozAnimation    = element.style.animation;
        element.style.oAnimation      = element.style.animation;
      };
			
      const setConfigError = (element, errorMessage)  => {
        element.style.backgroundColor = 'red';
        errorMessage = element.hasAttribute('title') ? (element.getAttribute('title') + '\u000d' + errorMessage) : errorMessage;
        element.setAttribute('title', errorMessage);
      };   
	  
      const showMessage = (e, message) => {
        let element    = document.getElementById('warning'); 
        let icon       = document.createElement('div');
        let iconholder = document.createElement('div');		
        let text       = document.createElement('div');
        
        iconholder.style.backgroundColor = '#ff9933';
        iconholder.style.width           = '15px';
        iconholder.style.height          = '15px';
        iconholder.style.borderRadius    = '2px';
        iconholder.style.marginLeft      = '2px';
        iconholder.style.marginTop       = '3px';
        iconholder.style.display         = 'inline-block';
        icon.style.marginTop             = '-4px';
        icon.innerHTML                   = '&#9888'; /* warning icon */	
        text.style.display               = 'inline-block';
        text.innerHTML = message;
        element.appendChild(iconholder);
        iconholder.appendChild(icon);
        element.appendChild(text);
        element.style.position        = 'absolute';
        element.style.left            = (e.target.getBoundingClientRect().left) + 'px';		
        element.style.top             = (e.target.getBoundingClientRect().bottom + 3) + 'px';
        element.style.width           = '450px';
        element.style.height          = '20px';
        element.style.display         = 'block';
        element.style.zIndex          = '99';
        setAnimation(element, 'fadein 0.5s, fadeout 0.5s 2.5s');

        // After 3 seconds, remove the show class from DIV
        setTimeout(() => {
          element.innerHTML     = '';
          element.style.display = 'none';
          setAnimation(element, '');
        }, 2500);
      }; 	  
	  
      const testAttributesValidity = element => { 	  
        if (element.hasAttribute('decimalSeparator') && !element.hasAttribute('numDecimals')) {
          setConfigError(element, 'numDecimals attribute should be set for elements with a defined decimalSeparator.');
          return 0;
        }
        return maxDigitsInFormat(element);
      };		
			
      const thousandsSeparator = element => element.hasAttribute('thousandsSeparator') ? element.getAttribute('thousandsSeparator') : thousandsSeparatorDefault();
	  
      const thousandsSeparatorDefault = () => decimalSeparatorDefault() === ',' ? '.' : ',';	  

      const updatethousandsSeparators = e => { 
        const elementValueOrg    = e.target.value;
        let   [intPart, decPart] = e.target.value.split(decimalSeparator(e.target));
        		
        if (isNegative(e.target.value)) {
          intPart = intPart.substring(1);
        }  

        intPart = removeThousandsSeparators(e.target, intPart); 
        intPart = intPart.length > 3 ? addThousandsSeparators(e, intPart) : intPart;

        if (decPart === undefined) {
          e.target.value = (isNegative(e.target.value) ? '-' : '') + intPart; 
        }	
        else {			  
          e.target.value = (isNegative(e.target.value) ? '-' : '') + intPart + decimalSeparator(e.target) + decPart;   
        } 
        if (isDeleteKey(e)) { 
          return numThousandsSeparators(e.target, e.target.value) - numThousandsSeparators(e.target, elementValueOrg);
        }
        if (e.key === 'Backspace') { 
          return numThousandsSeparators(e.target, e.target.value) - numThousandsSeparators(e.target, elementValueOrg) - 1;
        }
        return numThousandsSeparators(e.target, e.target.value) - numThousandsSeparators(e.target, elementValueOrg) + 1;       
      };
	  
      const validatePasteValue = e => {
        if (!isWholeValueSelected(e)) {
          return 'Paste only allowed when the current value is selected';
        } 
        if (!e.target.hasAttribute('allowNegativeSign') && e.clipboardData.getData('text/plain').startsWith('-')) {
          return 'Clipboard contains a negative value, this is not allowed';
        }		
        if (clipboardContainsDisallowedCharacters(e) 
            || (e.target.hasAttribute('allowNegativeSign') && e.clipboardData.getData('text/plain').lastIndexOf('-') > 0)) {
          return 'Clipboard contains invalid characters';
        } 
        if (e.clipboardData.getData('text/plain').startsWith('.') || e.clipboardData.getData('text/plain').startsWith(',')) {
          return 'Clipboard value should start with a digit'; 
        }
        if (!numDigitsInClipboardAllowed(e)) {
          return 'Clipboard contains more digits than allowed (' + maxDigitsInFormat(e.target) + ')';
        }
        if (isInputWithDecimals(e)) {
          if (numDecimalsInClipboard(e) > numDecimalsInFormat(e.target)) {
            return 'No more than ' + numDecimalsInFormat(e.target) + ' decimals allowed in clipboard';
          }
        }
        else {
          if (!numDecimalsInClipboard(e) === 0) {
            return 'Clipboard contains decimals, this is not allowed';
          }
        }
        return '';
      };	  
			
      document.onreadystatechange = () =>  {

        if (document.readyState == 'interactive') {
          insertStyleSheetRule('@keyframes         fadein  {from {bottom: 0;    opacity: 0;} to {bottom: 30px; opacity: 1;}}');
          insertStyleSheetRule('@-webkit-keyframes fadein  {from {bottom: 0;    opacity: 0;} to {bottom: 30px; opacity: 1;}}');
          insertStyleSheetRule('@keyframes         fadeout {from {bottom: 30px; opacity: 1;} to {bottom: 0;    opacity: 0;}}');
          insertStyleSheetRule('@-webkit-keyframes fadeout {from {bottom: 30px; opacity: 1;} to {bottom: 0;    opacity: 0;}}');	

          document.querySelectorAll('input.decimal').forEach(element => { 
            let dummy = testAttributesValidity(element);
			
            printDefaultValue(element);
			
            element.onpaste = e => { 
              return handleOnPaste(e);
            }	
			
            element.oncut = e => { 
              e.preventDefault(); // prevented for now, could be handled but the input value has to stay valid
              return false;			  
            }			
			
            element.oninput = () => {
              correctCharacterInputViaNumpadAndDeadKeys(element);
            }			

            element.onkeydown = e => { 
              return handleOnKeydown(e);
            }		 
          }); // end of foreach
        }
      }
    </script>
    <style>
      ::-ms-clear {display: none;}
    </style>
  </head>
  <body style='height: 100%;'>
    <form style='height: 100%;'>
      <div style="float: left; width: 29%; padding: 10px; box-sizing: border-box;">	
        <div>
          <label for='max9'>maxDigits 9, numDecimals 2, locale format</label>
          <br>
          <input name='max9' type='text' autofocus class='decimal' numDecimals='2' maxDigits='9' style='text-align: right; ' />
        </div>
        <br>	
        <div>
          <label for='max8Neg'>maxDigits 8, numDecimals 3, Negative numbers allowed, European format</label>
          <br>
          <input name='max8Neg' type='text' class='decimal' numDecimals='3' maxDigits='8' decimalSeparator=',' thousandsSeparator='.' allowNegativeSign style='text-align: right;' />
        </div>
        <br>		  
        <div>
          <label for='max8American'>maxDigits 8, numDecimals 3, American format</label>
     	  <br>
          <input name='max8American' type='text' class='decimal' numDecimals='3' maxDigits='8' decimalSeparator='.' thousandsSeparator=',' style='text-align: right;' />
        </div>
        <br>		  
        <div>	  
          <label for='max4'>maxDigits 4 locale format</label>
          <br>
          <input name='max4' type='text' class='decimal' maxDigits='4' style='text-align: right;' />
        </div>
        <br>	
        <div>	
          <label for='error'>maxDigits 0, numDecimals 0, indication of attributes-error </label>	
          <br>		
          <input name='error' type='text' class='decimal' numDecimals='0' maxDigits='0' style='text-align: right;' />	
        </div>
        <style>#warning:after {content: ' '; position: absolute; left: 30px; top: -5px; border-top: none;  border-right: 5px solid transparent;  border-left: 5px solid transparent;  border-bottom: 5px solid #ffff66;}</style>
	    <div id='warning' style='display:none; width:200px; height:15px; background-color:#ffff66;'></div> 
      </div>	
      <div style='float: left; width: 71%; height: 97%; padding: 10px; background-color:#f7f9f9; color: green; box-sizing: border-box; white-space: pre-line; overflow-y: auto'>
          This is a test / demo html file with javascript to handle a configurable input field for decimals. It works in
          at least the newest versions of Chrome, Firefox and Edge
          Configurable with HTML attributes in the decimal input field are:
          - numDecimals
          - maxDigits
          - decimalSeparator
          - thousandsSeparator
          - allowNegativeSign 
	  
          Design choices:
          - The selectionStart is taken as the cursor position in the following requirements
          - Formatting only takes place on keydown and paste for an optimal user experience
          - For maximum configurability the text input is used instead of number input
          - Configuration errors are indicated by coloring the inputfield red and assign it a tooltip with an errormessage
          - Fields for decimal input are marked with class='decimal'
          - maxDigits is a mandatory attribute for decimal input fields, the value should be > 0
          - If numDecimals > 0 maxDigits should be greater than numDecimals
          - If numDecimals > 0 the initial value shows numDecimals zero's right of the separator, one zero left of it
          - With all keydown and paste actions with the selectionstart position in the integer part thousands separators have to appear in the right positions
          - If no constraint is met the input is rejected (not printed)
          - If input is rejected on paste a validation message appears for three seconds
		  
          Requirements:

          - Behaviour on delete keydown
            With nothing selected
            - If the cursor is in the decimalpart change the value of the digit in zero and move the cursor one position to the right
            - If the cursor is in the integer part and left of the decimalSeparator or a thousandsSeparator move the cursor one position to the right
            - If the cursor is in the integer part, left of the only digit in the integer part change the value to zero and don't move the cursor
            - If the cursor is in the integer part, left of a digit which is not the only one in the integer part remove the digit and don't move the cursor
            With a selection
            - If the whole value is selected change the value to the default, the cursor should be left of the value
            - If the whole integerpart is selected replace it with a zero, put the cursor left of it
            - If a part of the integer- and decimalparts are selected replace the selected integer part with empty space and the selected decimals with zero's, don't move the cursor
	
          - Behaviour on backspace keydown
            With nothing selected  
            - If the cursor is in the decimal part and directly right of the decimalSeparator move the cursor one position to the left
            - If the cursor is in the integer part and right of a thousandsSeparator move the cursor one position to the left
            - If the cursor is in the integer part, on a position > 0 while there are > 1 digits in the integer part remove the digit and let the cursor at the same position
            - If the cursor is in the integer part, left of the decimalseparator / at the end of the integerpart of the number
              while there is 1 digit in the integer replace the digit with zero and move the cursor one position to the left
            - If after removal of a digit the integer part starts with more than one zero remove all zero's of the integer part except one, update the thousands-separators
            With a selection
            - Replace selected digits in the decimal part with zero
            - If the whole integerpart of the number is selected replace that part with zero and move the cursor to position zero
            - If a part of the integerpart is selected starting at position zero remove the selection and put the cursor to position zero
            - If a part of the integerpart is selected starting at a position that is not zero remove the selection. Put the cursor at the starting position of the removed part
		
          - Behaviour on decimalSeparator keydown
            - If the cursor is in the integer part move the cursor to the right of the decimalSeparator
		
          - Behaviour on digit keydown
            With nothing selected 
            - If the cursor is in the decimalpart replace the digit right of the cursor and put the cursor one position to the right
            - If the cursor is in the integer part on a position immediately left of the first digit and the integerpart value is zero (or -0) replace the zero and put the cursor one position to the right
            - If the cursor is in the integer part on a position immediately right of the first digit and the integerpart value is zero (or -0) replace the zero, cursor position not altered
            - If the cursor is in the integer part, on a position not left of the first digit, print the keyvalue, let the cursorposition the same
            - If the cursor is in the integer part on position zero and the keyvalue is zero no action follows (digit is not printed, cursor position not altered)
            With a selection
            - If the cursor is in the decimalpart replace the first selected with the typed digit, put the cursor right of the replaced digit
            - If the cursor is in the integer part, at position zero, keyvalue is zero and at least the whole integerpart is selected replace the integerpart with zero
              and put the cursor to position 1
            - If the cursor is in the integer part, at position zero, keyvalue is zero and less than the whole integerpart is selected the zero digit is not printed
              cursorposition stays the same		
            - If the cursor is in the integer part, at position zero, keyvalue is not zero replace the selected integerpart  with the typed digit one and put the cursor after
              the new digit
            - If the cursor is in the integer part, at a non-zero position and a digit is typed replace the selected integerpart with the typed digit one and put the cursor after
              the new digit

          - Behaviour on minus sign keydown (only if the attribute allowNegativeSign is set for the element)
            With nothing selected   
            - If the input value does not already start with a minus and the cursor is at position zero print the minus, put the cursor to the right of the minus
            - If the input value does start with a minus and the cursor is at position zero put the cursor to the right of the minus
            With a selection
            - If the selection starts at position zero, ends before the last integer digit while there are more than one digits in the integerpart 
              replace the selection with the minus, put the cursor after the minus
	 
          - Behaviour on select all
            This action is allowed	

          - Behaviour on cut 
            This action is disallowed for now 

          - Behaviour on copy
            This action is allowed 

          - Behaviour on paste 
            - A warning appears for three seconds when the action is not allowed  
            The paste is not allowed when
            - Not the whole input is selected
            - The clipboard value is not conform the input attribute values
            - The clipboard value contains invalid characters
            - The clipboard value does not start with a digit
      </div>
    </form>
  </body>
</html>